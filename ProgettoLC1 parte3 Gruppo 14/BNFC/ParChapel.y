-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParChapel where
import AbsChapel
import LexChapel
import ErrM

}

%name pS S
%name pProgram Program
%name pListStatement ListStatement
%name pStatement Statement
%name pBlockStatement BlockStatement
%name pFunctionCall FunctionCall
%name pFuncDeclaration FuncDeclaration
%name pParameterDecl ParameterDecl
%name pParameter Parameter
%name pListParameter ListParameter
%name pParameterList ParameterList
%name pListExpression ListExpression
%name pMode Mode
%name pDeclaration Declaration
%name pAssignment Assignment
%name pRange Range
%name pCast Cast
%name pPointer Pointer
%name pListPointer ListPointer
%name pLValue LValue
%name pRValue RValue
%name pArrayIndex ArrayIndex
%name pListArrayIndex ListArrayIndex
%name pArrayElement ArrayElement
%name pLiteralList LiteralList
%name pListLiteralList ListLiteralList
%name pWhileDo WhileDo
%name pDoWhile DoWhile
%name pIf If
%name pFor For
%name pTryCatch TryCatch
%name pExpression1 Expression1
%name pExpression2 Expression2
%name pExpression3 Expression3
%name pExpression4 Expression4
%name pExpression5 Expression5
%name pExpression6 Expression6
%name pExpression Expression
%name pValue Value
%name pLabel Label
%name pTypeSpec TypeSpec
%name pLiteral Literal
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '&' { PT _ (TS _ 2) }
  '&&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  '++' { PT _ (TS _ 8) }
  ',' { PT _ (TS _ 9) }
  '-' { PT _ (TS _ 10) }
  '--' { PT _ (TS _ 11) }
  '..' { PT _ (TS _ 12) }
  '/' { PT _ (TS _ 13) }
  ':' { PT _ (TS _ 14) }
  ';' { PT _ (TS _ 15) }
  '<' { PT _ (TS _ 16) }
  '<=' { PT _ (TS _ 17) }
  '=' { PT _ (TS _ 18) }
  '==' { PT _ (TS _ 19) }
  '>' { PT _ (TS _ 20) }
  '>=' { PT _ (TS _ 21) }
  '[' { PT _ (TS _ 22) }
  ']' { PT _ (TS _ 23) }
  'bool' { PT _ (TS _ 24) }
  'break' { PT _ (TS _ 25) }
  'catch' { PT _ (TS _ 26) }
  'char' { PT _ (TS _ 27) }
  'const' { PT _ (TS _ 28) }
  'continue' { PT _ (TS _ 29) }
  'do' { PT _ (TS _ 30) }
  'else' { PT _ (TS _ 31) }
  'for' { PT _ (TS _ 32) }
  'if' { PT _ (TS _ 33) }
  'in' { PT _ (TS _ 34) }
  'int' { PT _ (TS _ 35) }
  'proc' { PT _ (TS _ 36) }
  'real' { PT _ (TS _ 37) }
  'ref' { PT _ (TS _ 38) }
  'return' { PT _ (TS _ 39) }
  'string' { PT _ (TS _ 40) }
  'try' { PT _ (TS _ 41) }
  'val' { PT _ (TS _ 42) }
  'var' { PT _ (TS _ 43) }
  'void' { PT _ (TS _ 44) }
  'while' { PT _ (TS _ 45) }
  '{' { PT _ (TS _ 46) }
  '||' { PT _ (TS _ 47) }
  '}' { PT _ (TS _ 48) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }

S :: { S }
S : Program { AbsChapel.Init $1 }
Program :: { Program }
Program : ListStatement { AbsChapel.Prgrm (reverse $1) }
ListStatement :: { [Statement] }
ListStatement : {- empty -} { [] }
              | ListStatement Statement { flip (:) $1 $2 }
Statement :: { Statement }
Statement : BlockStatement { AbsChapel.Stmt1 $1 }
          | Expression ';' { AbsChapel.Stmt2 $1 }
          | Assignment { AbsChapel.Stmt4 $1 }
          | Declaration ';' { AbsChapel.Stmt5 $1 }
          | FuncDeclaration { AbsChapel.Stmt6 $1 }
          | WhileDo { AbsChapel.Stmt7 $1 }
          | DoWhile { AbsChapel.Stmt8 $1 }
          | For { AbsChapel.Stmt9 $1 }
          | If { AbsChapel.Stmt11 $1 }
          | TryCatch { AbsChapel.Stmt12 $1 }
          | 'break' ';' { AbsChapel.Stmt13 }
          | 'continue' ';' { AbsChapel.Stmt14 }
          | 'return' Expression ';' { AbsChapel.Stmt15 $2 }
BlockStatement :: { BlockStatement }
BlockStatement : '{' ListStatement '}' { AbsChapel.Bstmt (reverse $2) }
FunctionCall :: { FunctionCall }
FunctionCall : Label ParameterList { AbsChapel.Fcall1 $1 $2 }
FuncDeclaration :: { FuncDeclaration }
FuncDeclaration : 'proc' Label ParameterDecl Cast BlockStatement { AbsChapel.Fdec1 $2 $3 $4 $5 }
                | 'proc' Label ParameterDecl BlockStatement { AbsChapel.Fdec2 $2 $3 $4 }
                | 'proc' Label Cast BlockStatement { AbsChapel.Fdec3 $2 $3 $4 }
                | 'proc' Label BlockStatement { AbsChapel.Fdec4 $2 $3 }
ParameterDecl :: { ParameterDecl }
ParameterDecl : '(' ListParameter ')' { AbsChapel.ParDec $2 }
Parameter :: { Parameter }
Parameter : Mode Label Cast { AbsChapel.Par $1 $2 $3 }
ListParameter :: { [Parameter] }
ListParameter : {- empty -} { [] }
              | Parameter { (:[]) $1 }
              | Parameter ',' ListParameter { (:) $1 $3 }
ParameterList :: { ParameterList }
ParameterList : '(' ListExpression ')' { AbsChapel.ParLst $2 }
ListExpression :: { [Expression] }
ListExpression : {- empty -} { [] }
               | Expression { (:[]) $1 }
               | Expression ',' ListExpression { (:) $1 $3 }
Mode :: { Mode }
Mode : 'val' { AbsChapel.Mode1 }
     | 'ref' { AbsChapel.Mode2 }
     | 'const' { AbsChapel.Mode3 }
     | {- empty -} { AbsChapel.Mode4 }
Declaration :: { Declaration }
Declaration : 'var' ListPointer Label Cast { AbsChapel.Decl1 (reverse $2) $3 $4 }
Assignment :: { Assignment }
Assignment : Label '=' RValue ';' { AbsChapel.Asgmt1 $1 $3 }
           | 'var' ListPointer Label '=' RValue ';' { AbsChapel.Asgmt2 (reverse $2) $3 $5 }
           | Declaration '=' RValue ';' { AbsChapel.Asgmt3 $1 $3 }
Range :: { Range }
Range : Expression '..' Expression { AbsChapel.Rng1 $1 $3 }
      | Expression '..' { AbsChapel.Rng2 $1 }
      | '..' Expression { AbsChapel.Rng3 $2 }
      | '..' { AbsChapel.Rng4 }
Cast :: { Cast }
Cast : ':' TypeSpec { AbsChapel.Cast1 $2 }
     | ':' '[' Range ']' TypeSpec { AbsChapel.Cast2 $3 $5 }
Pointer :: { Pointer }
Pointer : '*' { AbsChapel.Ptr }
ListPointer :: { [Pointer] }
ListPointer : {- empty -} { [] }
            | ListPointer Pointer { flip (:) $1 $2 }
LValue :: { LValue }
LValue : Label { AbsChapel.Lval1 $1 }
       | Label ListArrayIndex { AbsChapel.Lval2 $1 $2 }
RValue :: { RValue }
RValue : Expression { AbsChapel.Rval1 $1 }
ArrayIndex :: { ArrayIndex }
ArrayIndex : '[' Expression ']' { AbsChapel.Arr1 $2 }
ListArrayIndex :: { [ArrayIndex] }
ListArrayIndex : ArrayIndex { (:[]) $1 }
               | ArrayIndex ListArrayIndex { (:) $1 $2 }
ArrayElement :: { ArrayElement }
ArrayElement : '(' ListLiteralList ')' { AbsChapel.Arrel $2 }
LiteralList :: { LiteralList }
LiteralList : Value { AbsChapel.Arrlst $1 }
ListLiteralList :: { [LiteralList] }
ListLiteralList : LiteralList { (:[]) $1 }
                | LiteralList ',' ListLiteralList { (:) $1 $3 }
WhileDo :: { WhileDo }
WhileDo : 'while' Expression BlockStatement { AbsChapel.Wd $2 $3 }
DoWhile :: { DoWhile }
DoWhile : 'do' BlockStatement 'while' Expression ';' { AbsChapel.Dw $2 $4 }
If :: { If }
If : 'if' Expression BlockStatement { AbsChapel.If1 $2 $3 }
   | 'if' Expression BlockStatement 'else' BlockStatement { AbsChapel.If2 $2 $3 $5 }
For :: { For }
For : 'for' Label 'in' Range BlockStatement { AbsChapel.For1 $2 $4 $5 }
    | 'for' Label 'in' Range 'do' Statement { AbsChapel.For2 $2 $4 $6 }
TryCatch :: { TryCatch }
TryCatch : 'try' Statement 'catch' Statement { AbsChapel.Trycat $2 $4 }
Expression1 :: { Expression }
Expression1 : Expression1 '&&' Expression2 { AbsChapel.Exp1 $1 $3 }
            | Expression1 '||' Expression2 { AbsChapel.Exp2 $1 $3 }
            | Expression2 { $1 }
Expression2 :: { Expression }
Expression2 : '!' Expression3 { AbsChapel.Exp3 $2 }
            | Expression3 { $1 }
Expression3 :: { Expression }
Expression3 : Expression3 '==' Expression4 { AbsChapel.Exp4 $1 $3 }
            | Expression3 '<' Expression4 { AbsChapel.Exp5 $1 $3 }
            | Expression3 '>' Expression4 { AbsChapel.Exp6 $1 $3 }
            | Expression3 '<=' Expression4 { AbsChapel.Exp7 $1 $3 }
            | Expression3 '>=' Expression4 { AbsChapel.Exp8 $1 $3 }
            | Expression4 { $1 }
Expression4 :: { Expression }
Expression4 : Expression4 '+' Expression5 { AbsChapel.Exp9 $1 $3 }
            | Expression4 '-' Expression5 { AbsChapel.Exp10 $1 $3 }
            | Expression4 '*' Expression5 { AbsChapel.Exp11 $1 $3 }
            | Expression4 '/' Expression5 { AbsChapel.Exp12 $1 $3 }
            | Expression5 { $1 }
Expression5 :: { Expression }
Expression5 : '++' Expression6 { AbsChapel.Exp13 $2 }
            | '--' Expression6 { AbsChapel.Exp14 $2 }
            | Expression6 '++' { AbsChapel.Exp15 $1 }
            | Expression6 '--' { AbsChapel.Exp17 $1 }
            | '*' Expression6 { AbsChapel.Exp18 $2 }
            | '&' Expression6 { AbsChapel.Exp19 $2 }
            | Expression6 { $1 }
Expression6 :: { Expression }
Expression6 : Value { AbsChapel.Exp20 $1 }
            | '(' Expression ')' { $2 }
Expression :: { Expression }
Expression : Expression1 { $1 }
Value :: { Value }
Value : LValue { AbsChapel.Val1 $1 }
      | Literal { AbsChapel.Val2 $1 }
      | FunctionCall { AbsChapel.Val3 $1 }
Label :: { Label }
Label : Ident { AbsChapel.Lbl $1 }
TypeSpec :: { TypeSpec }
TypeSpec : 'int' { AbsChapel.Typel1 }
         | 'real' { AbsChapel.Typel2 }
         | 'bool' { AbsChapel.Typel3 }
         | 'string' { AbsChapel.Typel4 }
         | 'char' { AbsChapel.Typel5 }
         | 'void' { AbsChapel.Typel6 }
Literal :: { Literal }
Literal : Integer { AbsChapel.Ltrl1 $1 }
        | Double { AbsChapel.Ltrl2 $1 }
        | Char { AbsChapel.Ltrl3 $1 }
        | String { AbsChapel.Ltrl4 $1 }
        | ArrayElement { AbsChapel.Ltrl5 $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

