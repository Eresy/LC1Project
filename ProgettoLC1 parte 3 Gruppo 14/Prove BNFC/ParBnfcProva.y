-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBnfcProva where
import AbsBnfcProva
import LexBnfcProva
import ErrM

}

%name pS S
%name pTopStatements TopStatements
%name pTopStatement TopStatement
%name pStatements Statements
%name pStatement Statement
%name pAssignment Assignment
%name pDefinition Definition
%name pFunctionDef FunctionDef
%name pLValue LValue
%name pRValue RValue
%name pType Type
%name pBool Bool
%name pTypeLabel TypeLabel
%name pInstructions Instructions
%name pInstruction Instruction
%name pFunctionCall FunctionCall
%name pParameters Parameters
%name pArguments Arguments
%name pFlowControl FlowControl
%name pIfThenElse IfThenElse
%name pThen Then
%name pElse Else
%name pWhile While
%name pFor For
%name pForInd ForInd
%name pForVars ForVars
%name pForVar ForVar
%name pLabel Label
%name pArray Array
%name pArrayDef ArrayDef
%name pArrayItems ArrayItems
%name pPointer Pointer
%name pExpression Expression
%name pOperand Operand
%name pOperator Operator
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&' { PT _ (TS _ 1) }
  '&&' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  '++' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '/' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '=' { PT _ (TS _ 12) }
  'False' { PT _ (TS _ 13) }
  'String' { PT _ (TS _ 14) }
  'True' { PT _ (TS _ 15) }
  '[' { PT _ (TS _ 16) }
  ']' { PT _ (TS _ 17) }
  'bool' { PT _ (TS _ 18) }
  'break' { PT _ (TS _ 19) }
  'continue' { PT _ (TS _ 20) }
  'double' { PT _ (TS _ 21) }
  'else' { PT _ (TS _ 22) }
  'for' { PT _ (TS _ 23) }
  'if' { PT _ (TS _ 24) }
  'int' { PT _ (TS _ 25) }
  'while' { PT _ (TS _ 26) }
  '{' { PT _ (TS _ 27) }
  '|' { PT _ (TS _ 28) }
  '||' { PT _ (TS _ 29) }
  '}' { PT _ (TS _ 30) }

L_integ  { PT _ (TI $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_doubl  { PT _ (TD $$) }
L_ident  { PT _ (TV $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Ident   :: { Ident }   : L_ident  { Ident $1 }

S :: { S }
S : TopStatements { AbsBnfcProva.init_ $1 }
TopStatements :: { TopStatements }
TopStatements : TopStatements TopStatement { AbsBnfcProva.tstats_ $1 $2 }
              | TopStatement { AbsBnfcProva.tstats2_ $1 }
TopStatement :: { TopStatement }
TopStatement : Definition ';' { AbsBnfcProva.tstat_ $1 }
Statements :: { Statements }
Statements : Statement Statements { AbsBnfcProva.stats_ $1 $2 }
           | {- empty -} { AbsBnfcProva.stats2_ }
Statement :: { Statement }
Statement : Assignment ';' { AbsBnfcProva.stat_ $1 }
          | Definition ';' { AbsBnfcProva.stat2_ $1 }
          | FunctionCall ';' { AbsBnfcProva.stat3_ $1 }
Assignment :: { Assignment }
Assignment : LValue '=' RValue { AbsBnfcProva.assign_ $1 $3 }
Definition :: { Definition }
Definition : TypeLabel LValue ';' { AbsBnfcProva.Def $1 $2 }
           | TypeLabel Assignment { AbsBnfcProva.Def2 $1 $2 }
           | FunctionDef { AbsBnfcProva.Def3 $1 }
FunctionDef :: { FunctionDef }
FunctionDef : TypeLabel Label '(' Arguments ')' '{' Instructions '}' { AbsBnfcProva.FDef $1 $2 $4 $7 }
LValue :: { LValue }
LValue : Label { AbsBnfcProva.Lval $1 }
       | Label Array { AbsBnfcProva.Lval2 $1 $2 }
       | Pointer Array { AbsBnfcProva.Lval3 $1 $2 }
RValue :: { RValue }
RValue : LValue { AbsBnfcProva.Rval $1 }
       | Type { AbsBnfcProva.Rval2 $1 }
       | Assignment { AbsBnfcProva.Rval3 $1 }
       | FunctionCall { AbsBnfcProva.Rval4 $1 }
       | ArrayDef { AbsBnfcProva.Rval5 $1 }
       | Expression { AbsBnfcProva.Rval6 $1 }
Type :: { Type }
Type : Integer { AbsBnfcProva.type_ $1 }
     | Char { AbsBnfcProva.type2_ $1 }
     | String { AbsBnfcProva.type3_ $1 }
     | Bool { AbsBnfcProva.type4_ $1 }
     | Double { AbsBnfcProva.type5_ $1 }
Bool :: { Bool }
Bool : 'True' { AbsBnfcProva.type6_ }
     | 'False' { AbsBnfcProva.type6_ }
TypeLabel :: { TypeLabel }
TypeLabel : 'int' { AbsBnfcProva.typel_ }
          | 'bool' { AbsBnfcProva.typel_ }
          | 'double' { AbsBnfcProva.typel_ }
          | 'String' { AbsBnfcProva.typel_ }
Instructions :: { Instructions }
Instructions : Instruction Instructions { AbsBnfcProva.insts_ $1 $2 }
             | {- empty -} { AbsBnfcProva.insts2_ }
Instruction :: { Instruction }
Instruction : Statements { AbsBnfcProva.instr_ $1 }
            | FlowControl { AbsBnfcProva.instr2_ $1 }
FunctionCall :: { FunctionCall }
FunctionCall : Label '(' Parameters ')' { AbsBnfcProva.fcall_ $1 $3 }
Parameters :: { Parameters }
Parameters : RValue Parameters { AbsBnfcProva.parm_ $1 $2 }
           | {- empty -} { AbsBnfcProva.parm2_ }
Arguments :: { Arguments }
Arguments : Type Label { AbsBnfcProva.args_ $1 $2 }
          | Type Label ',' Arguments { AbsBnfcProva.args2_ $1 $2 $4 }
FlowControl :: { FlowControl }
FlowControl : IfThenElse { AbsBnfcProva.fctrl_ $1 }
            | While { AbsBnfcProva.fctrl2_ $1 }
            | For { AbsBnfcProva.fctrl3_ $1 }
            | 'break' { AbsBnfcProva.fctrl4_ }
            | 'continue' { AbsBnfcProva.fctrl5_ }
IfThenElse :: { IfThenElse }
IfThenElse : 'if' '(' Expression ')' Then { AbsBnfcProva.if_ $3 $5 }
           | 'if' '(' Expression ')' Then Else { AbsBnfcProva.if2_ $3 $5 $6 }
Then :: { Then }
Then : '{' Instructions '}' { AbsBnfcProva.then_ $2 }
Else :: { Else }
Else : 'else' Then { AbsBnfcProva.else_ $2 }
While :: { While }
While : 'while' '(' Expression ')' '{' Instructions '}' { AbsBnfcProva.while_ $3 $6 }
For :: { For }
For : 'for' '(' ForInd ';' Expression ';' Expression ')' '{' Instructions '}' { AbsBnfcProva.for_ $3 $5 $7 $10 }
ForInd :: { ForInd }
ForInd : ForVars { AbsBnfcProva.forInd_ $1 }
       | {- empty -} { AbsBnfcProva.forInd2_ }
ForVars :: { ForVars }
ForVars : ForVar ',' ForVars { AbsBnfcProva.forVar_ $1 $3 }
        | ForVar { AbsBnfcProva.forVar2_ $1 }
ForVar :: { ForVar }
ForVar : Type LValue { AbsBnfcProva.forVar3_ $1 $2 }
Label :: { Label }
Label : Ident { AbsBnfcProva.lbl_ $1 }
Array :: { Array }
Array : '[' Integer ']' { AbsBnfcProva.arr_ $2 }
ArrayDef :: { ArrayDef }
ArrayDef : '{' ArrayItems '}' { AbsBnfcProva.Adef $2 }
ArrayItems :: { ArrayItems }
ArrayItems : RValue { AbsBnfcProva.Aitm $1 }
           | RValue ',' ArrayItems { AbsBnfcProva.Aitm2 $1 $3 }
Pointer :: { Pointer }
Pointer : '*' { AbsBnfcProva.ptr_ }
Expression :: { Expression }
Expression : Operand Operator Expression { AbsBnfcProva.expr_ $1 $2 $3 }
           | Operand { AbsBnfcProva.expr2_ $1 }
Operand :: { Operand }
Operand : Type { AbsBnfcProva.oper_ $1 }
Operator :: { Operator }
Operator : '+' { AbsBnfcProva.sum_ }
         | '-' { AbsBnfcProva.diff_ }
         | '/' { AbsBnfcProva.div_ }
         | '*' { AbsBnfcProva.mul_ }
         | '&' { AbsBnfcProva.andbw_ }
         | '|' { AbsBnfcProva.orbw_ }
         | '&&' { AbsBnfcProva.and_ }
         | '||' { AbsBnfcProva.or_ }
         | '++' { AbsBnfcProva.concat_ }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

