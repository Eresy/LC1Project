-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGrm where
import AbsGrm
import LexGrm
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '%=' { PT _ (TS _ 4) }
  '&' { PT _ (TS _ 5) }
  '&&' { PT _ (TS _ 6) }
  '&=' { PT _ (TS _ 7) }
  '(' { PT _ (TS _ 8) }
  ')' { PT _ (TS _ 9) }
  '*' { PT _ (TS _ 10) }
  '**' { PT _ (TS _ 11) }
  '**=' { PT _ (TS _ 12) }
  '*=' { PT _ (TS _ 13) }
  '+' { PT _ (TS _ 14) }
  '+=' { PT _ (TS _ 15) }
  ',' { PT _ (TS _ 16) }
  '-' { PT _ (TS _ 17) }
  '-=' { PT _ (TS _ 18) }
  '..' { PT _ (TS _ 19) }
  '/' { PT _ (TS _ 20) }
  '/=' { PT _ (TS _ 21) }
  ':' { PT _ (TS _ 22) }
  ';' { PT _ (TS _ 23) }
  '<' { PT _ (TS _ 24) }
  '<=' { PT _ (TS _ 25) }
  '=' { PT _ (TS _ 26) }
  '==' { PT _ (TS _ 27) }
  '>' { PT _ (TS _ 28) }
  '>=' { PT _ (TS _ 29) }
  'If' { PT _ (TS _ 30) }
  '[' { PT _ (TS _ 31) }
  ']' { PT _ (TS _ 32) }
  '^' { PT _ (TS _ 33) }
  '^=' { PT _ (TS _ 34) }
  'bool' { PT _ (TS _ 35) }
  'break' { PT _ (TS _ 36) }
  'catch' { PT _ (TS _ 37) }
  'char' { PT _ (TS _ 38) }
  'const' { PT _ (TS _ 39) }
  'continue' { PT _ (TS _ 40) }
  'do' { PT _ (TS _ 41) }
  'else' { PT _ (TS _ 42) }
  'false' { PT _ (TS _ 43) }
  'for' { PT _ (TS _ 44) }
  'if' { PT _ (TS _ 45) }
  'in' { PT _ (TS _ 46) }
  'int' { PT _ (TS _ 47) }
  'proc' { PT _ (TS _ 48) }
  'readChar' { PT _ (TS _ 49) }
  'readInt' { PT _ (TS _ 50) }
  'readString' { PT _ (TS _ 51) }
  'real' { PT _ (TS _ 52) }
  'ref' { PT _ (TS _ 53) }
  'return' { PT _ (TS _ 54) }
  'string' { PT _ (TS _ 55) }
  'then' { PT _ (TS _ 56) }
  'true' { PT _ (TS _ 57) }
  'try' { PT _ (TS _ 58) }
  'value' { PT _ (TS _ 59) }
  'var' { PT _ (TS _ 60) }
  'void' { PT _ (TS _ 61) }
  'while' { PT _ (TS _ 62) }
  'writeChar' { PT _ (TS _ 63) }
  'writeInt' { PT _ (TS _ 64) }
  'writeReal' { PT _ (TS _ 65) }
  'writeString' { PT _ (TS _ 66) }
  '{' { PT _ (TS _ 67) }
  '|' { PT _ (TS _ 68) }
  '|=' { PT _ (TS _ 69) }
  '}' { PT _ (TS _ 70) }

L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_Id { PT _ (T_Id $$) }
L_LInt { PT _ (T_LInt $$) }
L_LReal { PT _ (T_LReal $$) }


%%

Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Id    :: { Id} : L_Id { Id ($1)}
LInt    :: { LInt} : L_LInt { LInt ($1)}
LReal    :: { LReal} : L_LReal { LReal ($1)}

Program :: { Program }
Program : ListStmt { AbsGrm.Progr $1 }
ListId :: { [Id] }
ListId : Id { (:[]) $1 } | Id ',' ListId { (:) $1 $3 }
Boolean :: { Boolean }
Boolean : 'true' { AbsGrm.Boolean_true }
        | 'false' { AbsGrm.Boolean_false }
LString :: { LString }
LString : Char { AbsGrm.LStringChar $1 }
        | String { AbsGrm.LStringString $1 }
TypeSpec :: { TypeSpec }
TypeSpec : 'int' { AbsGrm.TypeSpec_int }
         | 'real' { AbsGrm.TypeSpec_real }
         | 'bool' { AbsGrm.TypeSpec_bool }
         | 'string' { AbsGrm.TypeSpec_string }
         | 'char' { AbsGrm.TypeSpec_char }
         | 'void' { AbsGrm.TypeSpec_void }
ListExp :: { [Exp] }
ListExp : Exp { (:[]) $1 } | Exp ',' ListExp { (:) $1 $3 }
Var_Decl_stmt :: { Var_Decl_stmt }
Var_Decl_stmt : Parameter ListVar_Decl { AbsGrm.VarDeclS $1 $2 }
Parameter :: { Parameter }
Parameter : 'const' { AbsGrm.Parameter_const }
          | 'ref' { AbsGrm.Parameter_ref }
          | 'value' { AbsGrm.Parameter_value }
          | 'var' { AbsGrm.Parameter_var }
ListVar_Decl :: { [Var_Decl] }
ListVar_Decl : Var_Decl { (:[]) $1 }
             | Var_Decl ',' ListVar_Decl { (:) $1 $3 }
Var_Decl :: { Var_Decl }
Var_Decl : ListId Type_part Init_part { AbsGrm.VarDecTI $1 $2 $3 }
         | ListId Init_part { AbsGrm.VarDecI $1 $2 }
         | ListId Type_part { AbsGrm.VarDec $1 $2 }
Type_part :: { Type_part }
Type_part : ':' TypeSpec { AbsGrm.TAss $2 }
Init_part :: { Init_part }
Init_part : '=' Exp { AbsGrm.Init $2 }
Exp :: { Exp }
Exp : Literal_exp { AbsGrm.ELiteral $1 }
    | Cast_exp { AbsGrm.ECast $1 }
    | LValue_exp { AbsGrm.ELValue $1 }
    | Unary_exp { AbsGrm.EUnary $1 }
    | Binary_exp { AbsGrm.EBinary $1 }
    | IF_exp { AbsGrm.EIf $1 }
    | For_exp { AbsGrm.EFor $1 }
    | Range_exp { AbsGrm.ERange $1 }
    | Constant { AbsGrm.EConstant $1 }
Constant :: { Constant }
Constant : Boolean { AbsGrm.ConstantBoolean $1 }
         | Integer { AbsGrm.ConstantInteger $1 }
         | Double { AbsGrm.ConstantDouble $1 }
         | Char { AbsGrm.ConstantChar $1 }
         | String { AbsGrm.ConstantString $1 }
Literal_exp :: { Literal_exp }
Literal_exp : Boolean { AbsGrm.Literal_expBoolean $1 }
            | LInt { AbsGrm.Literal_expLInt $1 }
            | LReal { AbsGrm.Literal_expLReal $1 }
            | LString { AbsGrm.Literal_expLString $1 }
Range_exp :: { Range_exp }
Range_exp : Exp '..' Exp { AbsGrm.Range_exp1 $1 $3 }
          | Exp '..' { AbsGrm.Range_exp2 $1 }
          | '..' Exp { AbsGrm.Range_exp3 $2 }
          | '..' { AbsGrm.Range_exp4 }
Cast_exp :: { Cast_exp }
Cast_exp : Exp ':' TypeSpec { AbsGrm.Cast $1 $3 }
LValue_exp :: { LValue_exp }
LValue_exp : LValue_exp '(' ListNamed_exp ')' { AbsGrm.FunCall $1 $3 }
           | Id { AbsGrm.Fname $1 }
           | '(' Exp ')' { AbsGrm.Parens $2 }
           | LArray { AbsGrm.Array $1 }
LArray :: { LArray }
LArray : Id ':' '[' ListRange_exp ']' { AbsGrm.LArray1 $1 $4 }
       | Id ':' '[' ListRange_exp ']' TypeSpec { AbsGrm.LArray2 $1 $4 $6 }
ListRange_exp :: { [Range_exp] }
ListRange_exp : Range_exp { (:[]) $1 }
              | Range_exp ',' ListRange_exp { (:) $1 $3 }
ListNamed_exp :: { [Named_exp] }
ListNamed_exp : Named_exp { (:[]) $1 }
              | Named_exp ',' ListNamed_exp { (:) $1 $3 }
Named_exp :: { Named_exp }
Named_exp : Exp { AbsGrm.Named_expExp $1 }
          | Id '=' Exp { AbsGrm.Named_exp1 $1 $3 }
Unary_exp :: { Unary_exp }
Unary_exp : Unary_op Exp { AbsGrm.UnaryE $1 $2 }
Unary_op :: { Unary_op }
Unary_op : '+' { AbsGrm.Unary_op1 }
         | '-' { AbsGrm.Unary_op2 }
         | '!' { AbsGrm.Unary_op3 }
Binary_exp :: { Binary_exp }
Binary_exp : Exp Binary_op Exp { AbsGrm.BinaryE $1 $2 $3 }
Binary_op :: { Binary_op }
Binary_op : '+' { AbsGrm.Binary_op1 }
          | '-' { AbsGrm.Binary_op2 }
          | '*' { AbsGrm.Binary_op3 }
          | '/' { AbsGrm.Binary_op4 }
          | '%' { AbsGrm.Binary_op5 }
          | '**' { AbsGrm.Binary_op6 }
          | '&' { AbsGrm.Binary_op7 }
          | '|' { AbsGrm.Binary_op8 }
          | '^' { AbsGrm.Binary_op9 }
          | '&&' { AbsGrm.Binary_op10 }
          | '==' { AbsGrm.Binary_op11 }
          | '!=' { AbsGrm.Binary_op12 }
          | '<=' { AbsGrm.Binary_op13 }
          | '>=' { AbsGrm.Binary_op14 }
          | '<' { AbsGrm.Binary_op15 }
          | '>' { AbsGrm.Binary_op16 }
IF_exp :: { IF_exp }
IF_exp : 'if' Exp 'then' Exp 'else' Exp { AbsGrm.IF_exp1 $2 $4 $6 }
       | 'If' Exp 'then' Exp { AbsGrm.IF_exp2 $2 $4 }
For_exp :: { For_exp }
For_exp : 'for' Id 'in' Exp 'do' Exp { AbsGrm.For_exp1 $2 $4 $6 }
        | 'for' Exp 'do' Exp { AbsGrm.For_exp2 $2 $4 }
Stmt :: { Stmt }
Stmt : Block_stmt { AbsGrm.SBlock $1 }
     | Assign_stmt { AbsGrm.SAssign $1 }
     | IO_stmt { AbsGrm.SIO $1 }
     | Cond_stmt { AbsGrm.SCondit $1 }
     | While_stmt { AbsGrm.SWhileDo $1 }
     | Do_stmt { AbsGrm.SDoWhile $1 }
     | For_stmt { AbsGrm.SFor $1 }
     | Break_stmt { AbsGrm.SBreak $1 }
     | Continue_stmt { AbsGrm.SContinue $1 }
     | Return_stmt { AbsGrm.SReturn $1 }
     | Proc_Decl_stmt { AbsGrm.SProcDecl $1 }
     | Var_Decl_stmt { AbsGrm.SVarDecl $1 }
     | TryCatch_stmt { AbsGrm.STryCatch $1 }
Block_stmt :: { Block_stmt }
Block_stmt : '{' ListStmt '}' { AbsGrm.BlockS $2 }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] }
         | Stmt { (:[]) $1 }
         | Stmt ';' ListStmt { (:) $1 $3 }
TryCatch_stmt :: { TryCatch_stmt }
TryCatch_stmt : 'try' Stmt 'catch' Stmt { AbsGrm.TryCatch $2 $4 }
Assign_stmt :: { Assign_stmt }
Assign_stmt : LValue_exp Assignment_op Exp { AbsGrm.AssignS $1 $2 $3 }
Assignment_op :: { Assignment_op }
Assignment_op : '=' { AbsGrm.Assign }
              | '+=' { AbsGrm.AssgnAdd }
              | '-=' { AbsGrm.AssgnSub }
              | '*=' { AbsGrm.AssgnMul }
              | '/=' { AbsGrm.AssgnDiv }
              | '%=' { AbsGrm.AssgnMod }
              | '**=' { AbsGrm.AssgnPow }
              | '&=' { AbsGrm.AssgnAnd }
              | '|=' { AbsGrm.AssgnOr }
              | '^=' { AbsGrm.AssgnXor }
IO_stmt :: { IO_stmt }
IO_stmt : 'writeInt' '(' ListExp ')' { AbsGrm.WriteI $3 }
        | 'readInt' '(' ListExp ')' { AbsGrm.ReadI $3 }
        | 'writeReal' '(' ListExp ')' { AbsGrm.WriteR $3 }
        | 'writeChar' '(' ListExp ')' { AbsGrm.WriteC $3 }
        | 'readChar' '(' ListExp ')' { AbsGrm.ReadC $3 }
        | 'writeString' '(' ListExp ')' { AbsGrm.WriteS $3 }
        | 'readString' '(' ListExp ')' { AbsGrm.ReadS $3 }
Cond_stmt :: { Cond_stmt }
Cond_stmt : 'if' Exp 'then' Stmt { AbsGrm.CondNoElseS $2 $4 }
          | 'if' Exp 'then' Stmt 'else' Stmt { AbsGrm.CondElseS $2 $4 $6 }
          | 'if' Exp Block_stmt { AbsGrm.CondNoElBlS $2 $3 }
          | 'if' Exp Block_stmt 'else' Stmt { AbsGrm.CondElBlS $2 $3 $5 }
While_stmt :: { While_stmt }
While_stmt : 'while' Exp 'do' Stmt { AbsGrm.WhileDo $2 $4 }
           | 'while' Exp Block_stmt { AbsGrm.While $2 $3 }
Do_stmt :: { Do_stmt }
Do_stmt : 'do' Stmt 'while' Exp { AbsGrm.DoWhile $2 $4 }
For_stmt :: { For_stmt }
For_stmt : 'for' Id 'in' Exp 'do' Stmt { AbsGrm.ForInDo $2 $4 $6 }
         | 'for' Id 'in' Exp Block_stmt { AbsGrm.ForIn $2 $4 $5 }
         | 'for' Exp 'do' Stmt { AbsGrm.ForDo $2 $4 }
         | 'for' Exp Block_stmt { AbsGrm.For $2 $3 }
Break_stmt :: { Break_stmt }
Break_stmt : 'break' { AbsGrm.Break_stmt_break }
           | 'break' Id { AbsGrm.Break_stmt1 $2 }
Continue_stmt :: { Continue_stmt }
Continue_stmt : 'continue' { AbsGrm.Continue_stmt_continue }
              | 'continue' Id { AbsGrm.Continue_stmt1 $2 }
Return_stmt :: { Return_stmt }
Return_stmt : 'return' { AbsGrm.Return_stmt_return }
            | 'return' Exp { AbsGrm.Return_stmt1 $2 }
Proc_Decl_stmt :: { Proc_Decl_stmt }
Proc_Decl_stmt : 'proc' Id Func_body { AbsGrm.ProcDef $2 $3 }
               | 'proc' Id Arg_list Func_body { AbsGrm.ProcDefArg $2 $3 $4 }
               | 'proc' Id Parameter Func_body { AbsGrm.ProcDefPar $2 $3 $4 }
               | 'proc' Id Ret_type Func_body { AbsGrm.ProcDefRet $2 $3 $4 }
               | 'proc' Id Arg_list Parameter Func_body { AbsGrm.ProcDefArP $2 $3 $4 $5 }
               | 'proc' Id Arg_list Ret_type Func_body { AbsGrm.ProcDefArR $2 $3 $4 $5 }
               | 'proc' Id Arg_list Parameter Ret_type Func_body { AbsGrm.ProcDefAPR $2 $3 $4 $5 $6 }
Arg_list :: { Arg_list }
Arg_list : '(' ListFormal ')' { AbsGrm.ArgumentLst $2 }
ListFormal :: { [Formal] }
ListFormal : {- empty -} { [] }
           | Formal { (:[]) $1 }
           | Formal ',' ListFormal { (:) $1 $3 }
Formal :: { Formal }
Formal : Id { AbsGrm.FormalId $1 }
       | Parameter Id { AbsGrm.Formal1 $1 $2 }
       | Id Type_part { AbsGrm.Formal2 $1 $2 }
       | Id Init_part { AbsGrm.Formal3 $1 $2 }
       | Id Type_part Init_part { AbsGrm.Formal4 $1 $2 $3 }
       | Parameter Id Type_part { AbsGrm.Formal5 $1 $2 $3 }
       | Parameter Id Type_part Init_part { AbsGrm.Formal6 $1 $2 $3 $4 }
Ret_type :: { Ret_type }
Ret_type : Type_part { AbsGrm.Ret_typeType_part $1 }
Func_body :: { Func_body }
Func_body : Block_stmt { AbsGrm.Func_bodyBlock_stmt $1 }
          | Return_stmt { AbsGrm.Func_bodyReturn_stmt $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

