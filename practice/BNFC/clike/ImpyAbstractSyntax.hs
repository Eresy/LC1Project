-- Haskell module generated by the BNF converter
--
-- Adapted by Marco Comini

{-# LANGUAGE FlexibleInstances #-}

module ImpyAbstractSyntax (
  module PrPrint,
  module TypesAbstractSyntax,
  module ImpyAbstractSyntax
) where

import PrPrint hiding (Doc)
-- import Print hiding (render)
import TypesAbstractSyntax

newtype VarIdent = Var String
  deriving (Eq,Ord,Show)

instance PrPrint VarIdent where
  prettyDoc = text . var2str

var2str (Var v) = v

data FunIdent = Fun String Int
  deriving (Eq,Ord,Show)

instance PrPrint FunIdent where
  prettyDoc (Fun name arity) = text name <> char '/' <> int arity


newtype Program = Prog [Decl]
  deriving (Eq,Ord,Show)

data Decl
 = Dvar VarIdent Type (Maybe (CompRExpr))
 | Dfun FunIdent Type [FormParam] [Decl] [Stmt]
  deriving (Eq,Ord,Show)

data FormParam = Par {
    pmdlty :: Modality,
    ptype :: Type,
    pvar :: VarIdent
  }
  deriving (Eq,Ord,Show)



data RExpr
 = InfixOp InfixOp RExpr RExpr
 | UnaryOp UnaryOp RExpr
 | FCall FunIdent [RExpr]
 | Const Const
 | LExpr LExpr
 | Ref LExpr
 | Coertion Type Type RExpr -- introduced by type checking
  deriving (Eq,Ord,Show)

data InfixOp = ArithOp ArithOp | RelOp RelOp | BoolOp BoolOp
  deriving (Eq,Ord,Show)

data ArithOp = Add | Sub | Mul | Div | Mod | Pow
  deriving (Eq,Ord,Show)

data BoolOp = And | Or | Xor | Iff | Implies | IsImplied
  deriving (Eq,Ord,Show)

data RelOp = Eq | Neq | Lt | LtE | Gt | GtE
  deriving (Eq,Ord,Show)

data UnaryOp = Not | Neg
  deriving (Eq,Ord,Show)

data Const = Bool Bool | Char Char | Float Double | Int Int | String String
  deriving (Eq,Ord,Show)


data LExpr
 = Ident VarIdent
 | ArrayEl LExpr RExpr
 | PrePostIncDecr PrePost IncDecr LExpr
 | Deref RExpr
  deriving (Eq,Ord,Show)

data PrePost = Post | Pre
  deriving (Eq,Ord,Show)

data IncDecr = Inc | Decr
  deriving (Eq,Ord,Show)


data CompRExpr
 = Basic RExpr
 | ArrayVal [CompRExpr]
  deriving (Eq,Ord,Show)


data Stmt
 = Assgn AssignmentOp LExpr RExpr
 | Block [Decl] [Stmt]
 | LExprStmt LExpr
 | IfNoElse RExpr Stmt
 | IfElse RExpr Stmt Stmt
 | While RExpr Stmt
 | DoWhile Stmt RExpr
 | Break
 | Continue
 | RetExp (Maybe RExpr)
 | DiscardRet RExpr  -- this is for procedures
                                -- put only functions inside!
 | Comment String
  deriving (Eq,Ord,Show)

data AssignmentOp = Assign | AssgnArith ArithOp | AssgnBool BoolOp
  deriving (Eq,Ord,Show)

-- instance PrPrint (FormParam vi) where
--   prettyDoc Par{pmdlty=m,ptype=t,pvar=v} =
--     prettyDoc m <+> prettyDoc t <+> prettyDoc v

-- instance PrPrint [FormParam vi] where
--   prettyDoc = parenCommaList

-- -- temporary
-- instance PrPrint (Program vi fi bi) where
--   prettyDoc _ = emptyDoc
--   toString = printTree

-- instance PrPrint (Decl) where
--   prettyDoc _ = emptyDoc
--   toString = printTree

-- instance PrPrint Stmt where
--   prettyDoc _ = emptyDoc
--   toString = printTree

-- instance PrPrint RExpr where
--   prettyDoc _ = emptyDoc
--   toString = printTree

-- instance PrPrint (CompRExpr) where
--   prettyDoc _ = emptyDoc
--   toString = printTree

-- instance PrPrint LExpr where
--   prettyDoc _ = emptyDoc
--   toString = printTree

-- prtPrettyDoc :: (PrPrint a) => a -> Doc
-- prtPrettyDoc = doc . showString . render . prettyDoc

-- instance Print Type where
--   prt i = prtPrettyDoc

-- instance Print Modality where
--   prt i = prtPrettyDoc

-- instance Print VarIdent where
--   prt i = prtPrettyDoc

-- instance Print FunIdent where
--   prt i = prtPrettyDoc

-- instance Print (Program vi fi bi) where
--   prt i e = case e of
--    Prog decls -> prPrec i 0 (concatD [prt 0 decls])

-- instance Print (Decl) where
--   prt i e = case e of
--    Dfun id typespec _ parameters ds cs -> prPrec i 0 (concatD [prt 0 typespec , doc (showString $ toString id) , prtPrettyDoc parameters, prt 0 (Block ds cs)])
--    Dvar id typespec _ optCompRE -> prPrec i 0 (concatD $ [prt 0 typespec , prt 0 id]++opt++[doc (showString ";")])
--      where
--        opt = case optCompRE of
--                (Just cmprexpr) -> [doc (showString "=") , prt 0 cmprexpr]
--                Nothing -> []

--   prtList es = case es of
--    [] -> (concatD [])
--    x:xs -> (concatD [prt 0 x , prt 0 xs])

-- instance Print (CompRExpr) where
--   prt i e = case e of
--    Basic rexpr -> prPrec i 0 (concatD [prt 0 rexpr])
--    ArrayVal cmprexprs -> prPrec i 0 (concatD [doc (showString "[") , prt 0 cmprexprs , doc (showString "]")])

--   prtList es = case es of
--    [x] -> (concatD [prt 0 x])
--    x:xs -> (concatD [prt 0 x , doc (showString ",") , prt 0 xs])

-- instance Print Stmt where
--   prt i e = case e of
--    Assgn assignment_op lexpr rexpr -> prPrec i 0 (concatD [prt 0 lexpr , prt 0 assignment_op , prt 0 rexpr , doc (showString ";")])
--    Block decls stmts -> prPrec i 0 (concatD [doc (showString "{") , prt 0 decls , prt 0 stmts , doc (showString "}")])
--    LExprStmt lexpr -> prPrec i 0 (concatD [prt 0 lexpr , doc (showString ";")])
--    While rexpr stmt -> prPrec i 0 (concatD [doc (showString "while") , doc (showString "(") , prt 0 rexpr , doc (showString ")") , prt 0 stmt])
--    DoWhile stmt rexpr -> prPrec i 0 (concatD [doc (showString "do") , prt 0 stmt , doc (showString "while") , doc (showString "(") , prt 0 rexpr , doc (showString ")")])
--    Break  -> prPrec i 0 (concatD [doc (showString "break") , doc (showString ";")])
--    Continue  -> prPrec i 0 (concatD [doc (showString "continue") , doc (showString ";")])
--    RetExp mbrexpr -> prPrec i 0 (concatD $ [doc (showString "return")]++prex++[doc (showString ";")])
--      where prex = case mbrexpr of Nothing -> [] ; (Just rexpr) -> [doc (showString "(") , prt 0 rexpr , doc (showString ")")]
--    IfNoElse rexpr stmt -> prPrec i 0 (concatD [doc (showString "if") , doc (showString "(") , prt 0 rexpr , doc (showString ")") , prt 0 stmt])
--    IfElse rexpr stmt0 stmt -> prPrec i 0 (concatD [doc (showString "if") , doc (showString "(") , prt 0 rexpr , doc (showString ")") , prt 0 stmt0 , doc (showString "else") , prt 0 stmt])
--    DiscardRet rexpr -> prt 0 rexpr -- prPrec i 0 (concatD [doc (showString $ fun2str id) , doc (showString "(") , s , doc (showString ")") , doc (showString ";")])
--    Comment str -> prPrec i 0 (concatD [doc (showString $ "# "++str), doc (showString ";")])

--   prtList es = case es of
--    [] -> (concatD [])
--    x:xs -> (concatD [prt 0 x , prt 0 xs])

-- instance Print AssignmentOp where
--   prt i e = case e of
--    Assign  -> prPrec i 0 (concatD [doc (showString "=")])
--    AssgnArith Mul  -> prPrec i 0 (concatD [doc (showString "*=")])
--    AssgnArith Add  -> prPrec i 0 (concatD [doc (showString "+=")])
--    AssgnArith Div  -> prPrec i 0 (concatD [doc (showString "/=")])
--    AssgnArith Sub  -> prPrec i 0 (concatD [doc (showString "-=")])
--    AssgnBool And  -> prPrec i 0 (concatD [doc (showString "&=")])
--    AssgnBool Xor  -> prPrec i 0 (concatD [doc (showString "^=")])
--    AssgnBool Or  -> prPrec i 0 (concatD [doc (showString "|=")])


-- instance Print RExpr where
--   prt i e = case e of
--    InfixOp (ArithOp Add) _ rexpr0 rexpr -> prPrec i 7 (concatD [prt 7 rexpr0 , doc (showString "+") , prt 8 rexpr])
--    InfixOp (ArithOp Div) _ rexpr0 rexpr -> prPrec i 8 (concatD [prt 8 rexpr0 , doc (showString "/") , prt 9 rexpr])
--    InfixOp (ArithOp Mod) _ rexpr0 rexpr -> prPrec i 8 (concatD [prt 8 rexpr0 , doc (showString "%") , prt 9 rexpr])
--    InfixOp (ArithOp Mul) _ rexpr0 rexpr -> prPrec i 8 (concatD [prt 8 rexpr0 , doc (showString "*") , prt 9 rexpr])
--    InfixOp (ArithOp Pow) _ rexpr0 rexpr -> prPrec i 9 (concatD [prt 10 rexpr0 , doc (showString "**") , prt 9 rexpr])
--    InfixOp (ArithOp Sub) _ rexpr0 rexpr -> prPrec i 7 (concatD [prt 7 rexpr0 , doc (showString "-") , prt 8 rexpr])
--    InfixOp (BoolOp And)  _ rexpr0 rexpr -> prPrec i 1 (concatD [prt 1 rexpr0 , doc (showString "&&") , prt 2 rexpr])
--    InfixOp (BoolOp Or)   _ rexpr0 rexpr -> prPrec i 0 (concatD [prt 0 rexpr0 , doc (showString "||") , prt 1 rexpr])
--    InfixOp (BoolOp Xor)  _ rexpr0 rexpr -> prPrec i 0 (concatD [prt 0 rexpr0 , doc (showString "^^") , prt 1 rexpr])
--    InfixOp (RelOp Eq)    _ rexpr0 rexpr -> prPrec i 5 (concatD [prt 6 rexpr0 , doc (showString "==") , prt 6 rexpr])
--    InfixOp (RelOp Gt)    _ rexpr0 rexpr -> prPrec i 5 (concatD [prt 6 rexpr0 , doc (showString ">") , prt 6 rexpr])
--    InfixOp (RelOp GtE)   _ rexpr0 rexpr -> prPrec i 5 (concatD [prt 6 rexpr0 , doc (showString ">=") , prt 6 rexpr])
--    InfixOp (RelOp Lt)    _ rexpr0 rexpr -> prPrec i 5 (concatD [prt 6 rexpr0 , doc (showString "<") , prt 6 rexpr])
--    InfixOp (RelOp LtE)   _ rexpr0 rexpr -> prPrec i 5 (concatD [prt 6 rexpr0 , doc (showString "<=") , prt 6 rexpr])
--    InfixOp (RelOp Neq)   _ rexpr0 rexpr -> prPrec i 5 (concatD [prt 6 rexpr0 , doc (showString "!=") , prt 6 rexpr])
--    UnaryOp (Neg) _ rexpr -> prPrec i 11 (concatD [doc (showString "-") , prt 12 rexpr])
--    UnaryOp (Not) _ rexpr -> prPrec i 2 (concatD [doc (showString "!") , prt 3 rexpr])
--    FCall fid _ _ rexprs -> prPrec i 12 (concatD [doc (showString $ toString fid) , doc (showString "(") , prt 0 rexprs , doc (showString ")")])
-- --   Const Void -> prPrec i 13 (concatD [doc $ showString "void"])
--    Const (Int n) -> prPrec i 13 (concatD [prt 0 n])
--    Const (Char c) -> prPrec i 13 (concatD [prt 0 c])
--    Const (Float x) -> prPrec i 13 (concatD [prt 0 x])
--    Const (String str) -> prPrec i 13 (concatD [prt 0 str])
--    Const (Bool b) -> prPrec i 13 (concatD [prt 0 b])
--    LExpr le -> prPrec i 14 (concatD [prt 0 le])
--    Ref le -> prPrec i 11 (concatD [doc (showString "&") , prt 0 le])
--    Coertion t1 t2 rexpr0 -> prPrec i 0 (concatD [doc (showString "("), prt 0 t1,doc (showString "->"),prt 0 t2,doc (showString ")"), prt 0 rexpr0])
-- --   x -> error $ "instance Print RExpr: undefined '"++show x++"'."

--   prtList es = case es of
--    [] -> (concatD [])
--    [x] -> (concatD [prt 0 x])
--    x:xs -> (concatD [prt 0 x , doc (showString ",") , prt 0 xs])

-- instance Print LExpr where
--   prt i e = case e of
--    Deref re -> prPrec i 0 (concatD [doc (showString "*"), prPrec i 0 (concatD [prt 0 re]) ])
--    PrePostIncDecr Pre  Inc  lexpr -> prPrec i 0 (concatD [doc (showString "++") , prt 1 lexpr])
--    PrePostIncDecr Pre  Decr lexpr -> prPrec i 0 (concatD [doc (showString "--") , prt 1 lexpr])
--    PrePostIncDecr Post Inc  lexpr -> prPrec i 1 (concatD [prt 2 lexpr , doc (showString "++")])
--    PrePostIncDecr Post Decr lexpr -> prPrec i 1 (concatD [prt 2 lexpr , doc (showString "--")])
--    ArrayEl _ blexpr rexpr -> prPrec i 2 (concatD [prt 0 blexpr , doc (showString "[") , prt 0 rexpr , doc (showString "]")])
--    Ident id _ -> prPrec i 2 (concatD [prt 0 id])

